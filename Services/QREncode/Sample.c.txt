//	---------------------------------------------------------------------------
//	QRGenerator
//
//	Created: 15/05/2013
//	Author:  TWOTM
//	Note:    /o ULTRAMUNDUM FOUNDATION - all rights reserved
//	---------------------------------------------------------------------------

// Includes

#include "stdafx.h"
#include <string.h>
#include <errno.h>
#include <conio.h>
#include <ctype.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <wchar.h>

#include "qrencode.h"


// Defines

#define QRCODE_TEXT					"http://peerproject.org/#username";		// Text to encode into QRCode
#define FILE_PATH					"c:/qrcode.bmp"								// Output file name
#define PIXEL_PRESCALER		6											// Prescaler (number of pixels in bmp file for each QRCode pixel, on each dimension)

#define PIXEL_COLOR_R				0											// Color of bmp pixels (0xff)
#define PIXEL_COLOR_G				0
#define PIXEL_COLOR_B				0

// BMP defines

typedef unsigned short	WORD;
typedef unsigned long	DWORD;
typedef signed long		LONG;

#define BI_RGB			0L

#pragma pack(push, 2)

typedef struct
{
	WORD    bfType;
	DWORD   bfSize;
	WORD    bfReserved1;
	WORD    bfReserved2;
	DWORD   bfOffBits;
} BITMAPFILEHEADER;

typedef struct
{
	DWORD      biSize;
	LONG       biWidth;
	LONG       biHeight;
	WORD       biPlanes;
	WORD       biBitCount;
	DWORD      biCompression;
	DWORD      biSizeImage;
	LONG       biXPelsPerMeter;
	LONG       biYPelsPerMeter;
	DWORD      biClrUsed;
	DWORD      biClrImportant;
} BITMAPINFOHEADER;

#pragma pack(pop)


/*
 * QRcode* QRcode_encodeString(szString, 0, QR_ECLEVEL_H, QR_MODE_8, TRUE))
 *
 * Create a symbol from the string. The library automatically parses
 * the input string and encodes in a QR Code symbol.
 * @warning This function is THREAD UNSAFE when pthread is disabled.
 * @param string input string. It must be NUL terminated.
 * @param version version of the symbol. If 0, the library chooses the minimum
 *                version for the given input data.
 * @param level error correction level.
 * @param hint tell the library how non-alphanumerical characters should be encoded.
 *             If QR_MODE_8 is given, all non-alphanumerical characters will be encoded as is.
 *             If you want to embed UTF-8 string, choose this.
 * @param casesensitive case-sensitive(1) or not(0).
 * @return an instance of QRcode class. The version of the result QRcode may
 *         be larger than the designated version. On error, NULL is returned,
 *         and errno is set to indicate the error. See Exceptions for the details.
 * @throw EINVAL invalid input object.
 * @throw ENOMEM unable to allocate memory for input objects.
 * @throw ERANGE input data is too large.
 */

// Main

int _tmain(int argc, _TCHAR* argv[])
{
	char*		szString = QRCODE_TEXT;
	unsigned char*	pRGBData, *pSourceData, *pDestData;
	unsigned int	nWidth, nWidthAdjusted, nDataBytes, x, y, l, n;

	// Compute QRCode

	QRcode* pQRC = QRcode_encodeString(szString, 0, QR_ECLEVEL_H, QR_MODE_8, 1);

	if (!pQRC)
	{
		printf("NULL returned");
		exit(-1);
	}

	nWidth = pQRC->width;
	nWidthAdjusted = nWidth * PIXEL_PRESCALER * 3;
	if (nWidthAdjusted % 4)
		nWidthAdjusted = (nWidthAdjusted / 4 + 1) * 4;
	nDataBytes = nWidthAdjusted * nWidth * PIXEL_PRESCALER;

	// Allocate pixels buffer

	if (!(pRGBData = (unsigned char*)malloc(nDataBytes)))
	{
		printf("Out of memory");
		exit(-1);
	}

	// Preset to white

	memset(pRGBData, 0xff, nDataBytes);

	// Convert QrCode bits to bmp pixels

	pSourceData = pQRC->data;
	for(y = 0; y < nWidth; y++)
	{
		pDestData = pRGBData + nWidthAdjusted * y * PIXEL_PRESCALER;
		for(x = 0; x < nWidth; x++)
		{
			if (*pSourceData & 1)
			{
				for(l = 0; l < PIXEL_PRESCALER; l++)
				{
					for(n = 0; n < PIXEL_PRESCALER; n++)
					{
						*(pDestData +     n * 3 + nWidthAdjusted * l) = PIXEL_COLOR_B;
						*(pDestData + 1 + n * 3 + nWidthAdjusted * l) = PIXEL_COLOR_G;
						*(pDestData + 2 + n * 3 + nWidthAdjusted * l) = PIXEL_COLOR_R;
					}
				}
			}
			pDestData += 3 * PIXEL_PRESCALER;
			pSourceData++;
		}
	}

	// Prepare bmp headers

	BITMAPFILEHEADER kFileHeader;
	kFileHeader.bfType = 0x4d42;  // "BM"
	kFileHeader.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + nDataBytes;
	kFileHeader.bfReserved1 = 0;
	kFileHeader.bfReserved2 = 0;
	kFileHeader.bfOffBits =	sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);

	BITMAPINFOHEADER kInfoHeader;
	kInfoHeader.biSize = sizeof(BITMAPINFOHEADER);
	kInfoHeader.biWidth = nWidth * PIXEL_PRESCALER;
	kInfoHeader.biHeight = -((int)nWidth * PIXEL_PRESCALER);
	kInfoHeader.biPlanes = 1;
	kInfoHeader.biBitCount = 24;
	kInfoHeader.biCompression = BI_RGB;
	kInfoHeader.biSizeImage = 0;
	kInfoHeader.biXPelsPerMeter = 0;
	kInfoHeader.biYPelsPerMeter = 0;
	kInfoHeader.biClrUsed = 0;
	kInfoHeader.biClrImportant = 0;

	// Output the bmp file

	FILE* file;

	if (!(fopen_s(&file, FILE_PATH, "wb")))
	{
		fwrite(&kFileHeader, sizeof(BITMAPFILEHEADER), 1, file);
		fwrite(&kInfoHeader, sizeof(BITMAPINFOHEADER), 1, file);
		fwrite(pRGBData, sizeof(unsigned char), nDataBytes, file);
		fclose(file);
	}
	else
	{
		printf("Unable to open file");
		exit(-1);
	}

	// Free data

	free(pRGBData);
	QRcode_free(pQRC);

	return 0;
}
